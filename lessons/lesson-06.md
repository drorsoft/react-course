<style>*{direction:rtl;}</style>
Please format this as an md file (in hebrew)
 
 # קורס ריאקט חלק ו' - טפסים

פתיחה ## 
עברנו על הרבה מהיכולות הבסיסיות של ריאקט. עכשיו ניגע בדבר נוסף שהוא חשוב בכל סוגי הישומים: טפסים. 

בעצם הטופס הוא אחד מהיסודות הבסיסים של הרשת, למשל, כל פעם שמתחברים לשירות, נגיד פייסבוק ממלאים טופס, שיש בו שם משתמש וסיסמה. 

אנחנו ניצור עכשיו טופס פשוט, שכשאני רוצה ליקנות גלידה אני ממלא בשביל לעשות הזמנה. נתחיל עם בניית טופס ניהול הסטייט שלו, טיפול בשגיאות. בפרק הבא נתעסק באיך לשלוח את הטופס, עם הטיפול בבקשות רשת.

יצירת עמוד ההזמנה ## 


אז קודם כל ניצור עמוד חדש עם נתיב משלו, ונקרא לו checkout. נוסיף אותו גם לנתיבים שלנו:
 
        <Route path="/checkout" element={<Checkout />} />


בתוכו, נעשה טופס בסיסי מעוצב
```
      <div id={'checkout-container'} className="w-96 h-3/4 border-2 border-slate-400 shadow  rounded-lg p-10 flex flex-col items-start justify-start gap-3">
                <h1 className="text-xl font-bold">
                    הזמנת גלידה
                </h1> 
                <p></p>
                <p></p>
            </div>
```

אינפוט 


עכשיו נתחיל את העבודה עם הטופס. נכיר שני תאגים חדשים (או לא חדשים של HTML):
form, input

ונכניס את שניהם:
```

     <form>
                    <input name="name"></input>
       </form>
```

פורם FORM:

אז ככה, פורם הוא לא טג חובה.  אבל מקובל לשים אותו, והוא נותן לנו כל מני אפשרויות שלא היינו יכולים לעשות בלעדיו. בעיקר האפשרות לתפוס את כל הטופס ולהוציא ממנו מידע. פחות נעמיק כאן בטכניקה הזו, אבל היא לא מסובכת. 

אינפוט INPUT

הרכיב הבסיסי והכי משומש ב FORM. זה בעצם רכיב של הדפדפן, שנותן לנו לרשום בתוכו דברים. עקרונית, הרכיב  של INPUT יכול להיות כל מני דברים ולא רק טקסט. בואו נראה בעמוד של MDN את כל האפשרויות:

https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input


בואו נראה מה קורה כשאנחנו מכניסים:

text
number
color
date
password
checkbox


כאן בלמידה נתעסק בעיקר בטקסט ומספרים, ובקצת סוגים אחרים. חשוב לזכור כל אלו הם לא דברים של ריאקט, הם דברים שבאים עם הHTML והדפדפן הוא זה שמעצב אותם, ומחליט על ההתנהגות. 

  
ניהול סטייט של האינפוט

אז אחד הבעיות של ריאקט או פריימווקס בכללי עם טפסים, הוא שיש כאן בעצם ניהול סטייט "כפול": הדפדפן כבר יודע לנהל את הסטייט של אינפוט. הוא זוכר מה היוזר כתב וכו'. וגם אם אנחנו לא ננהל את הסטייט שלו, הדפדפן יעשה זאת. 

אבל כן, אנחנו רוצים גם כאן לנהל את הסטייט. איך נעשה את זה:

עם 2 תכונות שריאקט נותן לנו:
value
onChange

נעשה את זה בצורה כזו:

      <input type="text" value={name} onChange={(e) => {
                            setName(e.target.value);
                        }}></input>


מה בעצם קורה כאן?

ריאקט נותן לנו גישה לארוע של הדפדפן שנקרא ONCHANGE. זאת בעצם פונקציה שיורה כל פעם כשהערך בתוך הקומפוננטה משתנה. אם נשים קונסול לוג נראה שזה לא ארוע של הדפדפן, אבל הוא מכיל את הארוע של הדפדפן. 

עכשיו שימו לב שבתוך הEVENT הזה שאנחנו רואים בקונסולה יש כמה דברים מעניינים:

nativeEvent

שזה בעצם הארוע שנורה מהדפדפן, וריאקט פשוט עטף אותו. אם היה לנו HTML רגיל זה מה שהייינו מקבלים


target

אם נלחץ בכלי המפתחים על ה TARGET בעצם נגיע לאלמנט שהוא היה ה"מטרה" של הארוע. שזה האינפוט. 

עכשיו שימו לב, אם נעיף את הsetName מה אתם חושבים שיקרה?

יפה, מה שיקרה הוא שהאינפוט לא יתעדכן בכלל. 

יצירת קומפוננטות אחידות
עכשיו נראה כיוון, שהוא לא מאפיין רק טפסים, אבל הוא הוא מאד מאפיין טפסים, וזה יצירת קומפוננטות לשימוש חוזר. למה?
כי יכול להיות שיהיו לנו באפליקציה כמה סוגים של טפסים, אבל בכולם נרצה לעשות את סוג של אינפוט במראה ובהתנהגות. 

אז נפתח תיקייה נוספת שנקרא לה UI. 
בתוכה נשים דברים שניתנים לשימוש חוזר. 

לפעמים תראו כל מני תיקיות עם שמות כמו 
common
shared
וכו' שמטרתם היא מעיין מכלול של קומפוננטות (לפעמים גם דברים אחרים) שמתמשים בהם בכל מני מקומות שונים באפליקציה
אני אקרא לקומפוננטה 

TextInput

export const TextInput = ({ label, value, onChange  }) => {
    return (
        <div>
            <label>
                {label}
                <input 
                    type="text"
                    value={value}
                    onChange={(e) => onChange(e.target.value)}
                />
            </label>
        </div>
    );
}


הסבר על נושא התווית LABLE: 

זה משהו שמאפיין טפסים של HTML, שאינו חובה, אבל מקובל, גם לצרכי נגישות, לייצר לכל אינפט תווית שמסבירה למשתמש מהו השדה הזה.


עכשיו בואו נצרוך אותה בטופס שלנו:

   <TextInput value={name} label={'שם'} onChange={setName} />


אוקי זה עובד. אבל נראה לא טוב. הואו נעצב את האינפוט של היישום שלנו שיראה טוב. 

עיצוב האינפוט


נתן לאינפוט שלנו פדינג (ריפוד) ו outline , שזה בעצם הקו שמקיף את האינפוט. 
שימו לב שהשתמשתי פה במשהו שנקרא פסודו-קלאס בCSS, שנקרא פוקוס. הוא בעצם אומר לנו האם האלמנט עכשיו הוא בפוקוס, זאת אומרת הוא בתשומת הלב של המשתמש. בכל רגע נתון יכול להיות פוקוס רק על אלמנט אחד בדפדפן. 


   className={`p-2 outline-1  outline-gray-300
     focus:outline-2 focus:outline-background-accent rounded-md`}


עיצוב התווית
חוץ מהאינפוט אני רוצה שהתווית של האינפוט תהיה קטנה יותר כי היא פחות חשובה. 

   <span className="text-sm text-gray-700 dark:text-gray-200">
                    {label}
                </span>


רוחב אינפוט ארוך 

עכשיו יש אלמנט שיכול להיות קצת מעצבן בעיצוב (CSS) כדי לדאוג שאלמנט יקח את כל המרחב, צריך שאם יש לו הורים הם גם יהיו עם w-full. אז בואו נעבור אחד אחד ונשים להם w-full

עכשיו האינפוט שלנו נראה בסדר. 

אבל יש עוד משהו שהוא טכניקה חשובה בריאקט, כשהשימוש המרכזי שלה הוא בטפסים:

פרופס ספרדינג

פרופס ספרדינה props spreading, זו טכניקה שבה אם אנחנו רוצים להעביר כל מני סוגים של פרופס מקומפוננטת האם, לילדים שלה, שאנחנו לא תמיד יודעים מראש, ניתן להשתמש בה:

export const TextInput = ({ label, value, onChange, ...props }) => {
...
<input
                    {...props}




מה הדבר הזה עושה? 
אני מזכיר שהדרך שבה אנחנו משתמשים בפרופס בקומפוננטה היא בטכניקה שנקראת דיסטרקטורינג, דהיינו אנחנו מפרקים את האובייקט שאנחנו מקבלים לחלקים.וזה בעצם אומר בדיוק כמו 

export const TextInput = (props) => {
    const label = props.label
    const value = props.value
    const onChange = props.onChange



אבל מה אם אנחנו רוצים לשים עוד דברים בפרופס? 

אז בעצם הספרדינג יביא לנו את כל שאר האלמנטים שדחפנו לשם. 

בואו נראה את זה בפעולה. אם נעשה קונסול לוג לפרופס, נראה שזה כרגע סתם אובייקט ריק. 

עכשיו ננסה להוסיף עוד תכונות ל TEXT INPUT

עכשיו, למה זה טוב? 

אם נראה את הדברים שאפשר להכניס לאינפוט נראה שהם רבים:

למשל, אפשר  הכניס לאינפוט 

disabled
type
placeholder

עכשיו אפשר להביא את כולם בקומפוננטה בצורה של drilling.

עכשיו נוסיף עוד שדה של placeholder שאומר להביא את השם ושם המשפחה

הוספת עוד שדות לטופס

עכשיו נרצה להכניס כמה שדות נוספים לטופס ההזמנה:

שם
אימייל
מספר טלפון
כתובת
אופן תשלום

אז נהפוך את הסטטיט שלנו מסטייט פשוט של מחרוזת לאובייקט

    const [order, setOrder] = useState({
        name: '',
        email: '',
        phone: '',
        address: '',
        paymentMethod: ''
    });


עכשיו כשאנחנו משנים את הסטייט בטופס זה קצת יותר מורכב, כי אנחנו לא רוצים לדרוס את כל הסטייט הקיים, אלא לעשות 


    <TextInput
                        
                            value={order.name}
                            label={'שם'}
                            onChange={(value) => setOrder(
                                {
                                    ...order,
                                    name: value
                                }
                            )} />


משימה - הוספת אימייל וכתובת לטופס

המשימה שלכם, להוסיף לטופס שלנו גם את האימייל והכתובת. 
 

אפשרות בחירה עם SELECT
נרצה שהמשתמשים שלנו יוכלו לבחור אם לשלם במזומן או בביט (כרגע בלי אשראי). לשם כך נשתמש בתאג שנקרא SELECT. מכיון שSELECT הבסיסי של הדפדפנים הוא די מכוער, אז לפעמים משתמשים ב SECLT מכל מני חבילות. למרות זאת אנחנו ננסה כן שהסלקט שלנו יראה יחסית דומה לאינפוט. 

export const AppSelect = ({ label, value, options, onChange, ...props }) => {
    return (
        <div className=" ">
            <label className="flex flex-col gap-2 w-full">
                <span className="text-sm text-gray-700 dark:text-gray-200 snuggle">
                    {label}
                </span>
                <select
                    {...props}
                    className={`p-2 outline-1  outline-gray-300
                        focus:outline-2 focus:outline-background-accent rounded-md w-full`}
                    value={value}
                    onChange={(e) => onChange(e.target.value)}
                >
                    {options.map((option, index) => (
                        <option key={index} value={option.value}>
                            {option.label}
                        </option>
                    ))}


                </select>
            </label>
        </div>
    );
}


שימו לב, העתקנו את הבסיסים מתוך הרכיב של האינפוט. אבל יש שינוי, התפריט של הסלקט מצפה ל מערך של אופציות. כל אופציה היא אובייקט שמצפה ל ערך, ותווית. 

כדי להציג אותם ב JSX אני משתמש בפונקציה של JS שנקראת MAP. הפוקנציה הזו, לוקחת מערך וממפה אותו למערך אחר. מכיוון שאנחנו ב JSX היא יכולה למפות אותו לאלמנט JSX של ריאקט. 

שימו לב שכשמשתמשים בפונקציה MAP, חייבים להעביר פרופרטי שנקראת KEY. למה? זו הדרך של ריאקט לדעת לאיזה אלמנט מתוך המערך להשוות. ה KEY חייב להיות יחודי. אחרת זה עושה בעיות בעדכון של ריאקט. 

 שינוי עיצוב 
שעיצוב ברירת המחדל של הסלקט, לפחות בכרום מראה לנו את החץ קרוב מדי לצד שלו. קודם כל יש כאן דוגמה שחוזרת לא מעט, שבעצם ברירות המחדל של הדפדפן, לא תמיד מוצאות חן בעינינו. ואנחנו נרצה לעקוף אותם בכל מני מובנים. אגב, אותו דבר יכול להיות שתהיה לנו ספריה של רכיבים מעוצבים  שלא נאהב אותה כל כך וננסה לעקוף אותה. 

אז מה נעשה כאן? 


משימה - להתמודד עם שינוי עיצוב 
למדריך: אפשרות: לתת משימה, שהיא קשה מהבסיס, לנסות להתמודד עם החץ של הסלקט, ולהעיף אותו. זה קצת מעצבן אבל זה אתגר למפתחים בפרונט להתעסק עם כל מני שטויות כאלו, גם של הדפדפן, וגם של ספריות. 






אנחנו יכולים להוריד את החץ, עם תכונה שיש גם בtailwind שנקראת apearance:none, שהיא בעצם ברכיבי INPUT ועוד רכיבים מורכבים, מעיפה את המראה \ פקדים של ברירת המחדל של הדפדפן. 
 appearance-none`


אבל עכשיו יש לנו עוד בעייה. אנחנו רוצים שתהיה איזו אינדיקציה לחץ הזה, אינדיקציה שזה תפריט 

   <span className="w-2 h-2 absolute top-11 left-4 rotate-45 font-bold text-slate-500 border-r-2 border-b-2 border-slate-400">
                </span>


הוספת כפתור שליחה

לפני שנגע בנושא הולידציה, נראה משהו מעניין לגבי השליחה. קודם כל נוסיף כפתור שליחה:
     <button type="submit" className="bg-slate-500 text-white p-2 rounded-md hover:bg-slate-600  "> שליחה</button>


שימו לב שנגדיר בסוג הכפתור, SUBMIT, ואת פעולת השליחה, עצמה, onSubmit נרשום על הטופס. זה לא חובה, אבל מקובל, לעשות כך. 

עכשיו בוא נראה מה קורה שאנחנו לוחצים על SUBMIT ?

שימו לב שהעמוד התרענן. למה זה קורה ? 

מה שקורה כאן, היא בעצם התנהגות ברירת מחדל של הדפדפן. בעקרון, ניתן לשלוח טפסים רק עם HTML ללא JS. איך זה קורה? בונים טופס עם HTML, בדומה למה שראינו כאן. ואז אם יש בתוך הטופס כפתור שנלחץ, או שלוחצים ENTER, הטופס נשלח! לאן, בעקרון, אם לא צויין כלום אז לאותה כתובת שאתם כאן. בדרך כלל מציינים את הכתובת בתכונה ACTION בתוך הטופס. 

איך מונעים את זה?

משתמשים במתודה שנמצאת כמעט בכל ה EVENTS בדפדפן. היא נקראת preventDefault. נשתמש בה כשאנחנו רוצה למנוע את התנהגות ברירת המחדל של הדפדפן. 

עכשיו בואו  נראה אם אנחנו משנים דברים בטופס האם רואים את זה בסטייט.  רואים. אבל תראו יש בעייה. הטופס לא נשלח, אם המייל לא עם ולידציה נכונה. 

אז תראו מה יש לנו כאן יש לנו התנגשות בין ברירת המחדל של הדפדפן, לבין מה שאנחנו רוצים לעשות. אז כרגע מה שנעשה נעקוף את ברירת המחדל של הדפדפן על ידי הוספת noValidate על הטופס. 

שימו לב שהפרקטיקות האלו מופיעות הרבה בפרונט, ובכלל בתוכנה. יש התנהגויות ברירת מחדל, אבל למרות שהן עובדות הן בסיסיות מדי, ואנחנו נרצה לעשות משהו יותר משוכלל. 





 ולידציה של הטופס

בטפסים משתמשים מזינים מידע. אבל התפקיד שלנו הוא לעשות ולידציה על מה שנכנס לטופס. אז יש כל מני דרכים לעשות את זה, יש גם כמה דרכים דרך הדפדפן, אבל הן קצת מוגבלות. 
אנחנו ניצור אובייקט של שגיאות, שיהיה מאד דומה לאובייקט של הטופס, שיגיד לנו האם הטופס מכיל שגיאות ואם כן אילו שגיאות. 

יש שיטות שונות להודיע למשתמש על בעיות בטופס. 

כיוון אחד, הוא לשים את הכפתור שליחה ב DISABLE, כל עוד היוזר לא מילא את כל השדות בצורה תקינה.
אנחנו ניקח גישה שנייה שכאשר היוזר ילחץ על "שלח", נראה את השגיאות שלו. 

אז נוסיף פונקציה שנקרא לה VALIDATE FORM. 
וגם נוסיף עוד אובייקט בסטייט שלנו שיכיל את השגיאות של הטופס


    const [validationErrors, setValidationErrors] = useState({
        name: '',
        email: '',
        phone: '',
        address: '',
        paymentMethod: ''
    });
    const validateForm = () => {
       


    }


עכשיו נוכל לעשות משהו כזה, שבודק לגבי כל השדות, אם הם חובה, אז נכניס את המילה לשגיאה שדה חובה

  if (order.name.trim() === '') {
            errors.name = 'שדה חובה';
        }
        if (order.email.trim() === '') {
            errors.email = 'שדה חובה';
        }
        if (order.phone.trim() === '') {
            errors.phone = 'שדה חובה';
        }

הסיבה שאנחנו משתמשים כאן ב TRIM מפני שהיא פונקציה שמקצצת רווחים מימין ומשמאל של מחרוזות טקסט. 

עכשיו בואו נדאג להציג את השגיאות בטופס עצמו. 

נכניס לכל שדה אינפוט את הערך של השגיאה. היא תופיע רק אם יש שגיאה

   <span className="text-xs text-red-800 h-5  ">
                {errorText}
            </span>


עכשיו בואו נחשוב על ריפקטורינג. 

אנחנו רוצים לעשות שכל השדות האלו יוגדרו כשדות חובה. אז איך נעשה את זה?

יש כמה דרכים אבל הדרך הפשוטה יחסית היא כך 

     for (const key in order) {
            if (order[key].trim() === '') {
                errors[key] = 'שדה חובה';
            }
        }


חוץ מאלו, נרצה גם לעשות ולידציה יותר מורכבת, של האימייל והטלפון. 

איך עושים את זה? 

משתמשים ברג'קסים. מה זה ביטויים רגולרים? 

אם נרצה למשל, לודא מספר טלפון, אז אפשר לקחת את כל החלקים שלו ולעשות המון IFS. אבל זה יהיה ארוך ולא יעיל. ולכן, יחסית מוקדם בהיסטוריה של המחשבים, הומצאו הביטויים הרגולרים. איך הם עובדים ? 

הם מתאימים דפוסים.  ביטוי רגולרי (Regular Expression, או בקיצור RegEx) הוא תבנית טקסטואלית שמאפשרת לחפש, להתאים או לתפעל טקסט בצורה גמישה ומדויקת. משתמשים בביטויים רגולריים כדי לזהות תבניות מסוימות בטקסט, כמו אימיילים, מספרי טלפון, או מילים מסוימות.


נראה דוגמא איך נעשה את זה עם מספר טלפון, ואז עם אימייל. 

  const phoneRegex = new RegExp(/^\d{10}$/);


    console.log('0541234567', phoneRegex.test('0541234567'));
    console.log('0541234567', phoneRegex.test('05412345678'));


ביטויים רגולרים, הם דברים קשים לתפעל, ולא נתעמק בהם ממש, רק נכיר כמה מהבסיסים שלהם. 

בואו נפרק את הביטוי הזה:
ה ^
אומר שזו התחלת הביטוי
\d אומר שזו ספרה
}10{ זה אומר שהיא צריכה לחזור על הקודם 10 פעמים
$ אומר שזה סוף הביטוי

עכשיו מה שנעשה זה נרשום שאם אין שגיאה קיימת (שגיאה שאין מספר) אז צריך לעשות את הולידציה. ואז אם התנאי לא עובר,  אז מוסיפים את השגיאה


    const phoneRegex = new RegExp(/^\d{10}$/);
        if (!errors.phone && !phoneRegex.test(order.phone)) {
            errors.phone = 'נא להכניס מספר טלפון תקין (10 ספרות)'; //  
        }


מכיוון שאני רוצה להוציא את הלוגיקה הזו, מהקובץ, אני אפתח תיקייה חדשה, ולידטורים, ואשים בה את הולידציה של הטלפון:

export const isValidMobilePhone = (phone) => {
    const phoneRegex = new RegExp(/^\d{10}$/);
    return phoneRegex.test(phone)
}




לגבי ולידציה של אימייל, זה נושא מאד סבוך, וזו גם שאלה מוצרית, וגם טכנית, במה רוצים לתמוך. 
כרגע, נעשה את זה מאד פשוט

/.+@.+\..+/;

שיתמוך גם בעוד שפות שאינן אנגלית, וכו'. 


סיכום

עכשיו יש לנו טופס שעובד, מקבל מידע, וגם מבצע ולידציה על המידע שהוא מקבל. 
השלב הבא שלנו הוא פנייה לרשת, שליחה וקבלה של מידע מהרשת. 



GitHub Copilot: ```markdown
# קורס ריאקט חלק ה' - טפסים

## פתיחה
עברנו על הרבה מהיכולות הבסיסיות של ריאקט. עכשיו ניגע בדבר נוסף שהוא חשוב בכל סוגי הישומים: **טפסים**.

בעצם הטופס הוא אחד מהיסודות הבסיסים של הרשת. לדוגמה, כל פעם שמתחברים לשירות, נגיד פייסבוק, ממלאים טופס שיש בו שם משתמש וסיסמה.

אנחנו ניצור עכשיו טופס פשוט, שכשאני רוצה לקנות גלידה אני ממלא אותו בשביל לעשות הזמנה. נתחיל עם בניית הטופס, ניהול הסטייט שלו, וטיפול בשגיאות. בפרק הבא נתעסק באיך לשלוח את הטופס, עם הטיפול בבקשות רשת.

---

## יצירת עמוד ההזמנה

### יצירת נתיב חדש
ניצור עמוד חדש עם נתיב משלו ונקרא לו `checkout`. נוסיף אותו גם לנתיבים שלנו:
```jsx
<Route path="/checkout" element={<Checkout />} />
```

### מבנה בסיסי של הטופס
בתוך הקומפוננטה נבנה טופס בסיסי ומעוצב:
```jsx
<div id={'checkout-container'} className="w-96 h-3/4 border-2 border-slate-400 shadow rounded-lg p-10 flex flex-col items-start justify-start gap-3">
    <h1 className="text-xl font-bold">הזמנת גלידה</h1>
    <p></p>
    <p></p>
</div>
```

---

## אינפוט (Input)

### שימוש בתגיות `form` ו-`input`
נכניס את התגיות הבסיסיות:
```jsx
<form>
    <input name="name"></input>
</form>
```

#### הסבר על `form`
`form` הוא לא תג חובה, אבל מקובל לשים אותו. הוא מאפשר לתפוס את כל הטופס ולהוציא ממנו מידע.

#### הסבר על `input`
`input` הוא הרכיב הבסיסי ביותר בטפסים. הוא מאפשר למשתמש להזין מידע. ניתן להגדיר סוגים שונים של אינפוטים כמו `text`, `number`, `color`, `date`, `password`, `checkbox` ועוד.

---

## ניהול סטייט של האינפוט

### ניהול סטייט עם `value` ו-`onChange`
```jsx
<input
    type="text"
    value={name}
    onChange={(e) => setName(e.target.value)}
></input>
```

#### מה קורה כאן?
- `onChange` היא פונקציה שנקראת בכל פעם שהערך משתנה.
- `setName` מעדכנת את הסטייט עם הערך החדש.

---

## יצירת קומפוננטות לשימוש חוזר

### קומפוננטת `TextInput`
```jsx
export const TextInput = ({ label, value, onChange }) => {
    return (
        <div>
            <label>
                {label}
                <input
                    type="text"
                    value={value}
                    onChange={(e) => onChange(e.target.value)}
                />
            </label>
        </div>
    );
};
```

#### שימוש בקומפוננטה
```jsx
<TextInput value={name} label={'שם'} onChange={setName} />
```

---

## עיצוב האינפוט

### עיצוב בסיסי
```jsx
className={`p-2 outline-1 outline-gray-300 focus:outline-2 focus:outline-background-accent rounded-md`}
```

### עיצוב התווית
```jsx
<span className="text-sm text-gray-700 dark:text-gray-200">
    {label}
</span>
```

---

## הוספת שדות נוספים לטופס

### ניהול סטייט מורכב
```jsx
const [order, setOrder] = useState({
    name: '',
    email: '',
    phone: '',
    address: '',
    paymentMethod: ''
});
```

### עדכון סטייט
```jsx
<TextInput
    value={order.name}
    label={'שם'}
    onChange={(value) =>
        setOrder({
            ...order,
            name: value
        })
    }
/>
```

---

## אפשרות בחירה עם `select`

### קומפוננטת `AppSelect`
```jsx
export const AppSelect = ({ label, value, options, onChange, ...props }) => {
    return (
        <div>
            <label className="flex flex-col gap-2 w-full">
                <span className="text-sm text-gray-700 dark:text-gray-200">
                    {label}
                </span>
                <select
                    {...props}
                    className={`p-2 outline-1 outline-gray-300 focus:outline-2 focus:outline-background-accent rounded-md w-full`}
                    value={value}
                    onChange={(e) => onChange(e.target.value)}
                >
                    {options.map((option, index) => (
                        <option key={index} value={option.value}>
                            {option.label}
                        </option>
                    ))}
                </select>
            </label>
        </div>
    );
};
```

---

## הוספת כפתור שליחה

### כפתור `submit`
```jsx
<button type="submit" className="bg-slate-500 text-white p-2 rounded-md hover:bg-slate-600">
    שליחה
</button>
```

---

## ולידציה של הטופס

### ניהול שגיאות
```jsx
const [validationErrors, setValidationErrors] = useState({
    name: '',
    email: '',
    phone: '',
    address: '',
    paymentMethod: ''
});
```

### פונקציית ולידציה
```jsx
const validateForm = () => {
    const errors = {};
    if (order.name.trim() === '') {
        errors.name = 'שדה חובה';
    }
    if (order.email.trim() === '') {
        errors.email = 'שדה חובה';
    }
    if (order.phone.trim() === '') {
        errors.phone = 'שדה חובה';
    }
    setValidationErrors(errors);
};
```

---

## סיכום

עכשיו יש לנו טופס שעובד, מקבל מידע, וגם מבצע ולידציה על המידע שהוא מקבל. השלב הבא שלנו הוא פנייה לרשת, שליחה וקבלה של מידע מהרשת.
```

