<style>*{direction:rtl;}</style>
 ChenPeleg: Turn this text to an md file like lesson 01

קורס ריאקט שיעור ב'

פתיחה
בפעם הקודמת התעסקנו עם התקנה וסידור ככה שתהיה לנו סביבת פיתוח שעובדת על המחשב. 
היום נעסוק בהבנת המבנים הבסיסיים של אפליקציית ריאקט ואיך היא פועלת.

 
פתיחה
בניית קומפוננטה של הכותרת
הערה לגבי אם ה VS-CODE מנסה לבדוק TYEPSCRIPT
ניהול סטייט בקומפוננטה
הוספת גלידה - ופרופס
דחיפת פרופס לקומפוננטה
צורות נוספות של סינטקסט
משימה - הוספת כפתור נוסף


נקודות על העבודה - ומבנה הפרוייקט
 

כמו שעשינו פעם שעברה הריצו npm run dev. זה בעצם מפעיל את שרת הפיתוח, ולכן חשוב שתוודאו שתהליך הזה, פועל בכל פעם שאתם עובדים על הקוד שלכם.

אז בואו נעבור על כל הקבצים והתיקיות שיש לנו כאן. ברמת השורש, יש לנו כמה קבצי קונפיגורציה, אני רוצה לחזור להתייחס לpackage/json שהוא בעצם ה"רכז" של הפרוייקט שלנו.
אז אפשר לראות בראש הקובץ, את שם הפרוייקט. אפשר לראות גם את התלויות של הפרויקט שלנו מוגדרות ב  package.json. אנחנו יכולים לראות שיש לנו כמה תלויות -  depenencies. זה בעצם אומר, שהקוד שלנו זקוק לספריות, או אפליקציות האלו כדי לרוץ. הוא מתבסס עליהן. 

הדבר הבא שנראה הוא איזור ה scripts: אתם יכולים להריץ את הסקריפטים האלה עם npm run ואז שם הסקריפט.

אנחנו נשתמש לרוב בפקודה npm run dev - זו  פקודה שמתחילה את שרת הפיתוח הזה' צופה בכל הקוד שלנו, מסדרת אותו בצורה שתהיה נוחה לפדפן לקרוא אותו. כמו שנראה היום, הקוד של ריאקט לא כתוב בצורה שהדפדפן יודע לקרוא אותו. אז מה שהריאקט, וגם VITE עושים זה לעשות שינוי בקוד, יש לזה כל מני שמות אבל לרוב נקרא לזה קומפילציה - להפוך אותו מקוד שקריא לנו, לקוד שקריא למכונה, במקרה שלנו דפדפן. (המונח הטכני המדוייק יותר הוא טרנספילציה אבל כולם משתמשים במילה קומפילציה)


ברגע שאתם מוכנים לפרוס את האפליקציה שלכם, תריצו npm run build כדי : א. לבצע אופטימיזציה נוספת, שהקוד יהיה יותר קטן, וגם שיהיה מסודר יותר להגשה מתוך שרת. נחזור לזה בשיעור הבא. 

אז בואו נסגור את קובץ package.json. תיקיית node modules מחזיקה את כל התלויות ותת-התלויות של הפרויקט שלנו, זו הסיבה שיש לנו כל כך הרבה. אתם לא צריכים לערוך שום דבר בתיקיית node modules,
היא נוצרת אוטומטית אם תריצו npm install בתיקיית הפרויקט שלכם. היא בעצם המקום שבו יושב כל הקוד של האפליקציות שהתקנתם, ולרוב אנחנו לא נגע שם אלא במקרים מאד נדירים. 

תיקיית public : היא בעצם תיקיית השורש שמוגשת על ידי שרת האינטרנט בסופו של דבר, לרוב נשים בה כל מני דברים קבועים כמו תמונות או האיקון של האתר. 

  קובץ   index.html, זהו דף html רגיל וזהו הדף היחיד שיש לנו כאן.אנחנו  לא נוסיף עוד דפי html בפרויקט הזה. איך זה יכול להיות? 
כי מה שהריאקט יעשה זה בעצם שקבצי הסקריפט שלנו יוזרקו על ידי תהליך הבנייה הזה.

בואו נדגיש כאן רק דבר אחד חשוב כרגע לגבי הקובץ HTML :  את ה-div הזה עם ה-ID root,זה המקום שבו ה-react. בעצם יזריק את הקוד ויכתוב לנו את ה HTML הסופי. 
 קבצי הסקריפט נמצאים בתיקיית source. - SRC




  תיקיית source, כאן יש לנו כמה קבצים ואלה בעצם הקבצים שבהם נעבוד, זו בעצם אפליקציית react שלנו.

החשוב ביותר עבורנו כרגע, קובץ index.js מקבל גישה לאלמנט root הזה ב-dom שלנו, בקובץ html שלנו, אז האלמנט עם ה-ID root שהוא כמובן ה-div הזה שראינו בקובץ index.html, זהו, וכפי שאתם יכולים לראות, הוא מרנדר את אפליקציית react שלנו עם פונקציה שנקראת render.
 
המלצה: להשתמש בספריה atom aterial icons כמו שאני משתמש
 
קומפוננטות ו JSX

אז בעצם האופן שבו נעבוד עם ריאקט הוא שבריאקט היחידה הבסיסית הקטנה נקראת קומפוננטה. קומפוננטה יכולה להיות דף שלם, אבל היא גם יכולה להיות איקון. 

אני רוצה שנתחיל בלכתוב קומפוננטה. לשם כך, צריך שגם נעשה קצת תזכורת בנושא JS. בעצם ה JS הוא שילוב של HTML ו JS. לגבי ה HTML לא צריך לזכור הרבה דברים חוץ מעקרון אחד חשוב, שצריך לסגור תגים שפותחים. לגבי JS אנחנו נעשה גם תזכורות וגם בעצם נעמיק בכמה יסודות בשפה שריאקט משתמש בהם. הראשונה, והחשובה ביותר היא הפונקציה. 

פונקציה זה בעצם חתיכה של קוד שרצה כשקוראים לה. פונקציה יכולה להחזיר ערך או לא. כל קומפוננטה בריאקט היא פונקציה. 

בואו נבנה את הקומפוננטה הראשונה שלנו. 

נפתח תקייה בתוך SRC שנקרא לה components. 

בניית קומפוננטה של הכותרת

הקומפוננטה הראשונה שלנו תהיה הכותרת של היישום. נקרא לקובץ AppHeader.



 export function AppHeader() {
    return "החנות שלי"
}




עכשיו ננסה להסביר מה בעצם יש בקובץ הזה של הקומפוננטה:
יש את המילה export:  היא אומרת שבעצם הקובץ הזה מייצא את הפונקציה הזו. עקרונית אפשר לייצא כמה דברים מקובץ, אבל זה בדרך כלל לא מומלץ. 
יש את המילה function : שזה בעצם אומר ל JS שאנחנו מגדירים פונקציה. 
ובפונרציה יש רק שורה אחת return. 
היא מחזירה מחרוזת. 

הערה לגבי אם ה VS-CODE מנסה לבדוק TYEPSCRIPT
אנחנו עובדים עם VS CODE והוא מהקופסא יודע לבדוק את הקבצים שלנו, ולוודא שהאופן שבו אנחנו כותבים JS הוא תקין. מה שיקרה זה שהוא יעיר לנו על כל מני דברים אם הוא חושב שהם לא נכונים. כדי לעזור לו, נשים בתקיית ה ROOT קובץ jsconfig.json:


{
    "compilerOptions": {
        "checkJs": true,
        "jsx": "react-jsx",
        "types": [
            "vite/client",
        ],
    },
    "exclude": [
        "node_modules",
        "**/node_modules/*"
    ]
}




עכשיו נשים את הפונקציה בתוך האפליקציה:


 
import { AppHeader } from './components/AppHeader'
...


 <AppHeader />
      <h1>Vite + React</h1>
...



כדי ליבא את הקומפוננטה, אנחנו נשתמש בהוראה import, ואז נשים את השם של הפונקציה בסוגריים מסולסלים. 

בהמשך נראה כמה סוגים \ צורות שאפשר לעשות יבוא מקבצים, אבל זה הסוג המומלץ ביותר. 



שימו לב שה VS יתן לנו השלמה אוטומטית, ואז גם ייבא את הקומפוננטה מהמקום שלה. 

בשלב הבא נשפר קצת את ה קומפוננטה: 

נשים את הטקסט בתוך H1. 
נמחק את הטקסט של הכותרת המקורית

ניהול סטייט בקומפוננטה

הרבה מהעבודה של התעסקות עם UI קשורה בניהול סטייט. מה זה סטייט? זה בעצם המצב הנוכחי של האפליקציה שברובו נשמר בזיכרון. דוגמאות לסטייט:
מה שהקלדתי בטופס
תפריט פתוח או סגור
האם אני משתמש מחובר או לא 

ועוד ועוד. 

איך מנהלים סטייט בריאקט? 

בתוך הקומפוננטה הקיימת, שבאה כברירת המחדל, יש לי בעצם את השורה הבאה


 
  const [count, setCount] = useState(0)




יש כאן כמה עניינים מורכבים ננסה לפרק את זה דבר דבר, וגם נעמיק יותר כשנעמיק בהמשך ב JS:

const 
 זה בעצם הכרזת משתנה קבוע בJS. 

הסינטקסט הזה, עם הסוגריים המרובעים בעצם אומר כך



 const useStateResult = useState(0)
 const count = useStateResult[0];
 const setCount = useStateResult[1];



זאת אומרת היא מחזירה מערך עם שני איברים. הראשון הוא הערך של ה COUNT. השני היא פונקציה. 

כן - זה דבר מורכב להבין וזה חלק מהאופי של JS שנעמיק בו בהמשך. בעצם מה שיש לנו כאן זו פונקציה שמחזירה פונקציה. 

איך שמקובל להשתמש בזה, הוא להשתמש בשם, ואז לשים את המילה set לפניו כדי להשתמש בפונקציה. 

עכשיו נשנה את השם שם המשתנים האלו, כי נרצה בעצם שהכפתור הזה ישנה לנו את סוג הגלידה שנרצה לבחור. 

  const [serveType, setServeType] = useState('cone') // cone | cup

ואז נוסיף עוד פונקציה שתטפל בלחיצה על הכפתור

  const [serveType, setServeType] = useState('cone') // cone | cup
  function clickServeType() {
    if (serveType === 'cone') {
      setServeType('cup')
    } else {
      setServeType('cone')
    }
  }

ובכפתור נשנה ל 

     <button onClick={() => clickServeType()}>
          count is {serveType}
        </button>


שימו לב שכאן בתוך ה onclick יש לנו משהו שנקרא Arrow function עוד מעט נדבר על זה. 

בואו קודם כל נראה שזה עובד אצל כולם

עכשיו נדבר על arrow function

בגדול זה סינקטס יותר מתקדם של JS. מה ההבדל:

פונקציה היא משתנה (גם פונקציה רגילה היא משתנה ויכולה להיות אנונימית דהיינו ללא שם, אבל השם שלה מוכרז לרוב אחרי המילה פונקציה)
הדרך שבה היא מוגדרת היא עם סוגריים (שיכולים להכיל את הערכים שלה) ואז חץ שמורכב מ שווה וגדול, ואז גוף הפונקציה. 

בעקרון מבחינתכם אין הבדל ביניהם ב 99 אחוז מהמצבים, יש הבדל אחד שהוא יותר רלוונטי למצב שנמצאים בתוך קלאס.

אפשר להשתמש בשני הצורות, אבל מקובל יותר להתשמש בפונקציית ARROW. 

הוספת גלידה - ופרופס

אז דיברנו על זה שיכול להיות לכל קומפוננטה מצב פנימי. אבל מה אם רוצים שקומפוננטה אחת תשפיע על אחרת?

זה אחד הנקודות הכי מרכזיות של ריאק: העדכון הוא תמיד מלעלה למטה. זאת אומרת ההורים משפיעים על הילדים. ועל הנכדים וכו'. 

עכשיו בעצם נעשה דבר כזה, נוסיף קומפוננטה שנקרא לה 
IceCream


עכשיו אני רוצה להעביר לקומפוננטה מידע  מהקומפוננטה הראשית. 

איך עושים את זה ?

פונקציה של קומפוננטות בעצם מקבלות משתנה אחד שנקרא props. אפשר לקרוא לו איך שרוצים, אבל הוא תמיד יהיה אחד. 

אז  ניצור קומפוננטה בסיסית, נראה שהיא מופיעה על המסך ונשים אותה בAPP:
 
 export const IceCream = () => {
    return (<div>Ice cream</div >)
}




ניצור אותה עם פונקצית ARROW. 

עכשיו אנחנו רוצים שהגלידה שלנו שאנחנו רואים את התמונה שלה, תראה אם המשתמש בחר גביע או כוס. יש כל מני דרכים לעשות את זה, אני עשיתי משהו יחסית בסיסי ב CSS, אחרי זה אפשר להחליף את זה עם תמונות ועוד, כרגע, ממליץ לעשות COPY PAST ממה שאני עשיתי, ובהמשך כשנעמיק ב CSS ובתצוגה בכלל נוכל לעשות שינוים בזה. 

אז לקחת את הקובץ IceCream.css, נייביא אותו בצורה פשוטה יחסית, על כל זה בהמשך. 

נוסיף גם ישור שאחרי זה נתעסק במשמעות שלו

   <AppHeader />
      <div style={{ display: 'flex', justifyContent: 'center' }}>
        <IceCream />
      </div>


עכשיו אנחנו ורוצים להעביר PROPS לקומפוננטה של הגלידה. איך עושים את זה?


דחיפת פרופס לקומפוננטה

בקומפוננטה עצמה נוסיף את הארגומנט, פרופס. 

export const IceCream = (props) => {
    console.log(props)
    return (
        <div className="cup"></div>
    )
}

עכשיו בואו נראה איך אנחנו מעבירים פרופס:

     <IceCream serveType={serveType} />


עכשיו נפתח את הקונסולה ונראה מה בעצם קרה כאן. כל פעם שהקומפוננטה אב משתנה, הפונקציה של הבן (גלידה) רצה מחדש. ואז מה שקורה זה שריאקט מרנדר מחדש אם צריך את הקומפוננטת בן. 

עכשיו בואו נעשה עוד משהו, ננסה להשפיע על הבן, באמצעות האב. 

נעשה דבר כזה:

   return (
        <div className={props.serveType}></div>
    )


צורות נוספות של סינטקסט

בכל שיעור או שניים, נעשה העמקה ב JS, מפני שבעצם, ריאקט בנוייה עם JS וכמה תוספות. אז דבר ראשון נדבר על DESTRUCTORING: 

בעצם ב JS, יש לנו אובייקטים, בתור האופן המרכזי להכיל סוגי מידע מורכבים. דרך אחת לגשת לפרופרטייז (לתכונות) של האובייקטים היא על ידי dot notation.
דרך נוסף היא DESTRUCTORING
Ternay experssion
היא שיטה נוספת לבצע בקרת זרימה של IF ELSE פשוט. 

 
const person = { firsName: 'John', age: 30 };
const { firsName, age } = person;


// ternary expression
const isAdult = age > 18 ? 'yes' : 'no';








עכשיו נראה איך נשנה את הקומפוננטה שלנו, לשימוש בשיטות האלו. 

export const IceCream = ({ serveType }) => {


    return (
        <div className={serveType === 'cone' ? 'cone' : 'cup'}></div>
    )
}

עכשיו מדוע אנחנו שמים את הסוג של ההגשה בביטוי TERNARY ? 

בגלל שכדי להפריד את הדרך שבה אנחנו מייצגים את המידע במקומות שונים, כי אם נרצה לשנות את שם הקלאס בעתיד, אז זה יאפשר לנו לעשות את זה בצורה יותר קלה. 

משימה - הוספת כפתור נוסף 

אז הנה המשימות בקבוצות קטנות:
למחוק את הסמלים React + Vite שבאו כברירת מחדל
לשנות את הטקסט של הכפתור לעברית
להוסיף עוד כפתור, שייצג האם אנחנו רוצים שוקולד או וניל




GitHub Copilot: Here is the content converted to an MD file similar to lesson-01.md:

```markdown
# קורס ריאקט שיעור ב'

## פתיחה
בפעם הקודמת התעסקנו עם התקנה וסידור ככה שתהיה לנו סביבת פיתוח שעובדת על המחשב. 
היום נעסוק בהבנת המבנים הבסיסיים של אפליקציית ריאקט ואיך היא פועלת.

## פתיחה
- בניית קומפוננטה של הכותרת
- הערה לגבי אם ה VS-CODE מנסה לבדוק TYEPSCRIPT
- ניהול סטייט בקומפוננטה
- הוספת גלידה - ופרופס
- דחיפת פרופס לקומפוננטה
- צורות נוספות של סינטקסט
- משימה - הוספת כפתור נוסף

## נקודות על העבודה - ומבנה הפרוייקט

כמו שעשינו פעם שעברה הריצו `npm run dev`. זה בעצם מפעיל את שרת הפיתוח, ולכן חשוב שתוודאו שתהליך הזה, פועל בכל פעם שאתם עובדים על הקוד שלכם.

אז בואו נעבור על כל הקבצים והתיקיות שיש לנו כאן. ברמת השורש, יש לנו כמה קבצי קונפיגורציה, אני רוצה לחזור להתייחס ל`package.json` שהוא בעצם ה"רכז" של הפרוייקט שלנו.
אז אפשר לראות בראש הקובץ, את שם הפרוייקט. אפשר לראות גם את התלויות של הפרויקט שלנו מוגדרות ב `package.json`. אנחנו יכולים לראות שיש לנו כמה תלויות - `depenencies`. זה בעצם אומר, שהקוד שלנו זקוק לספריות, או אפליקציות האלו כדי לרוץ. הוא מתבסס עליהן. 

הדבר הבא שנראה הוא איזור ה `scripts`: אתם יכולים להריץ את הסקריפטים האלה עם `npm run` ואז שם הסקריפט.

אנחנו נשתמש לרוב בפקודה `npm run dev` - זו פקודה שמתחילה את שרת הפיתוח הזה' צופה בכל הקוד שלנו, מסדרת אותו בצורה שתהיה נוחה לפדפן לקרוא אותו. כמו שנראה היום, הקוד של ריאקט לא כתוב בצורה שהדפדפן יודע לקרוא אותו. אז מה שהריאקט, וגם VITE עושים זה לעשות שינוי בקוד, יש לזה כל מני שמות אבל לרוב נקרא לזה קומפילציה - להפוך אותו מקוד שקריא לנו, לקוד שקריא למכונה, במקרה שלנו דפדפן. (המונח הטכני המדוייק יותר הוא טרנספילציה אבל כולם משתמשים במילה קומפילציה)

ברגע שאתם מוכנים לפרוס את האפליקציה שלכם, תריצו `npm run build` כדי : א. לבצע אופטימיזציה נוספת, שהקוד יהיה יותר קטן, וגם שיהיה מסודר יותר להגשה מתוך שרת. נחזור לזה בשיעור הבא. 

אז בואו נסגור את קובץ `package.json`. תיקיית `node_modules` מחזיקה את כל התלויות ותת-התלויות של הפרויקט שלנו, זו הסיבה שיש לנו כל כך הרבה. אתם לא צריכים לערוך שום דבר בתיקיית `node_modules`,
היא נוצרת אוטומטית אם תריצו `npm install` בתיקיית הפרויקט שלכם. היא בעצם המקום שבו יושב כל הקוד של האפליקציות שהתקנתם, ולרוב אנחנו לא נגע שם אלא במקרים מאד נדירים. 

תיקיית `public`: היא בעצם תיקיית השורש שמוגשת על ידי שרת האינטרנט בסופו של דבר, לרוב נשים בה כל מני דברים קבועים כמו תמונות או האיקון של האתר. 

קובץ `index.html`, זהו דף html רגיל וזהו הדף היחיד שיש לנו כאן.אנחנו לא נוסיף עוד דפי html בפרויקט הזה. איך זה יכול להיות? 
כי מה שהריאקט יעשה זה בעצם שקבצי הסקריפט שלנו יוזרקו על ידי תהליך הבנייה הזה.

בואו נדגיש כאן רק דבר אחד חשוב כרגע לגבי הקובץ HTML: את ה-div הזה עם ה-ID root, זה המקום שבו ה-react. בעצם יזריק את הקוד ויכתוב לנו את ה HTML הסופי. 
קבצי הסקריפט נמצאים בתיקיית `source` - `SRC`.

תיקיית `source`, כאן יש לנו כמה קבצים ואלה בעצם הקבצים שבהם נעבוד, זו בעצם אפליקציית react שלנו.

החשוב ביותר עבורנו כרגע, קובץ `index.js` מקבל גישה לאלמנט root הזה ב-dom שלנו, בקובץ html שלנו, אז האלמנט עם ה-ID root שהוא כמובן ה-div הזה שראינו בקובץ `index.html`, זהו, וכפי שאתם יכולים לראות, הוא מרנדר את אפליקציית react שלנו עם פונקציה שנקראת render.

המלצה: להשתמש בספריה `atom material icons` כמו שאני משתמש.

## קומפוננטות ו JSX

אז בעצם האופן שבו נעבוד עם ריאקט הוא שבריאקט היחידה הבסיסית הקטנה נקראת קומפוננטה. קומפוננטה יכולה להיות דף שלם, אבל היא גם יכולה להיות איקון. 

אני רוצה שנתחיל בלכתוב קומפוננטה. לשם כך, צריך שגם נעשה קצת תזכורת בנושא JS. בעצם ה JS הוא שילוב של HTML ו JS. לגבי ה HTML לא צריך לזכור הרבה דברים חוץ מעקרון אחד חשוב, שצריך לסגור תגים שפותחים. לגבי JS אנחנו נעשה גם תזכורות וגם בעצם נעמיק בכמה יסודות בשפה שריאקט משתמש בהם. הראשונה, והחשובה ביותר היא הפונקציה. 

פונקציה זה בעצם חתיכה של קוד שרצה כשקוראים לה. פונקציה יכולה להחזיר ערך או לא. כל קומפוננטה בריאקט היא פונקציה. 

### בניית קומפוננטה של הכותרת

נפתח תקייה בתוך `SRC` שנקרא לה `components`.

הקומפוננטה הראשונה שלנו תהיה הכותרת של היישום. נקרא לקובץ `AppHeader`.

```javascript
export function AppHeader() {
    return "החנות שלי"
}
```

עכשיו ננסה להסביר מה בעצם יש בקובץ הזה של הקומפוננטה:
יש את המילה `export`: היא אומרת שבעצם הקובץ הזה מייצא את הפונקציה הזו. עקרונית אפשר לייצא כמה דברים מקובץ, אבל זה בדרך כלל לא מומלץ. 
יש את המילה `function`: שזה בעצם אומר ל JS שאנחנו מגדירים פונקציה. 
ובפונקציה יש רק שורה אחת `return`. 
היא מחזירה מחרוזת. 

### הערה לגבי אם ה VS-CODE מנסה לבדוק TYEPSCRIPT
אנחנו עובדים עם VS CODE והוא מהקופסא יודע לבדוק את הקבצים שלנו, ולוודא שהאופן שבו אנחנו כותבים JS הוא תקין. מה שיקרה זה שהוא יעיר לנו על כל מני דברים אם הוא חושב שהם לא נכונים. כדי לעזור לו, נשים בתקיית ה ROOT קובץ `jsconfig.json`:

```json
{
    "compilerOptions": {
        "checkJs": true,
        "jsx": "react-jsx",
        "types": [
            "vite/client"
        ]
    },
    "exclude": [
        "node_modules",
        "**/node_modules/*"
    ]
}
```

### עכשיו נשים את הפונקציה בתוך האפליקציה:

```javascript
import { AppHeader } from './components/AppHeader'
...

<AppHeader />
<h1>Vite + React</h1>
...
```

כדי ליבא את הקומפוננטה, אנחנו נשתמש בהוראה `import`, ואז נשים את השם של הפונקציה בסוגריים מסולסלים. 

בהמשך נראה כמה סוגים \ צורות שאפשר לעשות יבוא מקבצים, אבל זה הסוג המומלץ ביותר. 

שימו לב שה VS יתן לנו השלמה אוטומטית, ואז גם ייבא את הקומפוננטה מהמקום שלה. 

### בשלב הבא נשפר קצת את הקומפוננטה:

נשים את הטקסט בתוך `H1`. 
נמחק את הטקסט של הכותרת המקורית.

### ניהול סטייט בקומפוננטה

הרבה מהעבודה של התעסקות עם UI קשורה בניהול סטייט. מה זה סטייט? זה בעצם המצב הנוכחי של האפליקציה שברובו נשמר בזיכרון. דוגמאות לסטייט:
- מה שהקלדתי בטופס
- תפריט פתוח או סגור
- האם אני משתמש מחובר או לא 

ועוד ועוד. 

איך מנהלים סטייט בריאקט? 

בתוך הקומפוננטה הקיימת, שבאה כברירת המחדל, יש לי בעצם את השורה הבאה:

```javascript
const [count, setCount] = useState(0)
```

יש כאן כמה עניינים מורכבים ננסה לפרק את זה דבר דבר, וגם נעמיק יותר כשנעמיק בהמשך ב JS:

`const` 
זה בעצם הכרזת משתנה קבוע בJS. 

הסינטקסט הזה, עם הסוגריים המרובעים בעצם אומר כך:

```javascript
const useStateResult = useState(0)
const count = useStateResult[0];
const setCount = useStateResult[1];
```

זאת אומרת היא מחזירה מערך עם שני איברים. הראשון הוא הערך של ה COUNT. השני היא פונקציה. 

כן - זה דבר מורכב להבין וזה חלק מהאופי של JS שנעמיק בו בהמשך. בעצם מה שיש לנו כאן זו פונקציה שמחזירה פונקציה. 

איך שמקובל להשתמש בזה, הוא להשתמש בשם, ואז לשים את המילה `set` לפניו כדי להשתמש בפונקציה. 

### עכשיו נשנה את השם שם המשתנים האלו, כי נרצה בעצם שהכפתור הזה ישנה לנו את סוג הגלידה שנרצה לבחור.

```javascript
const [serveType, setServeType] = useState('cone') // cone | cup
```

ואז נוסיף עוד פונקציה שתטפל בלחיצה על הכפתור:

```javascript
const [serveType, setServeType] = useState('cone') // cone | cup
function clickServeType() {
    if (serveType === 'cone') {
        setServeType('cup')
    } else {
        setServeType('cone')
    }
}
```

ובכפתור נשנה ל:

```javascript
<button onClick={() => clickServeType()}>
    count is {serveType}
</button>
```

שימו לב שכאן בתוך ה `onclick` יש לנו משהו שנקרא `Arrow function` עוד מעט נדבר על זה. 

בואו קודם כל נראה שזה עובד אצל כולם.

### עכשיו נדבר על arrow function

בגדול זה סינקטס יותר מתקדם של JS. מה ההבדל:

פונקציה היא משתנה (גם פונקציה רגילה היא משתנה ויכולה להיות אנונימית דהיינו ללא שם, אבל השם שלה מוכרז לרוב אחרי המילה פונקציה)
הדרך שבה היא מוגדרת היא עם סוגריים (שיכולים להכיל את הערכים שלה) ואז חץ שמורכב מ שווה וגדול, ואז גוף הפונקציה. 

בעקרון מבחינתכם אין הבדל ביניהם ב 99 אחוז מהמצבים, יש הבדל אחד שהוא יותר רלוונטי למצב שנמצאים בתוך קלאס.

אפשר להשתמש בשני הצורות, אבל מקובל יותר להתשמש בפונקציית ARROW. 

### הוספת גלידה - ופרופס

אז דיברנו על זה שיכול להיות לכל קומפוננטה מצב פנימי. אבל מה אם רוצים שקומפוננטה אחת תשפיע על אחרת?

זה אחד הנקודות הכי מרכזיות של ריאק: העדכון הוא תמיד מלעלה למטה. זאת אומרת ההורים משפיעים על הילדים. ועל הנכדים וכו'. 

עכשיו בעצם נעשה דבר כזה, נוסיף קומפוננטה שנקרא לה `IceCream`.

### עכשיו אני רוצה להעביר לקומפוננטה מידע מהקומפוננטה הראשית.

איך עושים את זה?

פונקציה של קומפוננטות בעצם מקבלות משתנה אחד שנקרא `props`. אפשר לקרוא לו איך שרוצים, אבל הוא תמיד יהיה אחד. 

אז ניצור קומפוננטה בסיסית, נראה שהיא מופיעה על המסך ונשים אותה בAPP:

```javascript
export const IceCream = () => {
    return (<div>Ice cream</div>)
}
```

ניצור אותה עם פונקצית ARROW. 

### עכשיו אנחנו רוצים שהגלידה שלנו שאנחנו רואים את התמונה שלה, תראה אם המשתמש בחר גביע או כוס. יש כל מני דרכים לעשות את זה, אני עשיתי משהו יחסית בסיסי ב CSS, אחרי זה אפשר להחליף את זה עם תמונות ועוד, כרגע, ממליץ לעשות COPY PAST ממה שאני עשיתי, ובהמשך כשנעמיק ב CSS ובתצוגה בכלל נוכל לעשות שינוים בזה. 

אז לקחת את הקובץ `IceCream.css`, נייביא אותו בצורה פשוטה יחסית, על כל זה בהמשך. 

נוסיף גם ישור שאחרי זה נתעסק במשמעות שלו:

```javascript
<AppHeader />
<div style={{ display: 'flex', justifyContent: 'center' }}>
    <IceCream />
</div>
```

### עכשיו אנחנו ורוצים להעביר PROPS לקומפוננטה של הגלידה. איך עושים את זה?

### דחיפת פרופס לקומפוננטה

בקומפוננטה עצמה נוסיף את הארגומנט, פרופס:

```javascript
export const IceCream = (props) => {
    console.log(props)
    return (
        <div className="cup"></div>
    )
}
```

### עכשיו בואו נראה איך אנחנו מעבירים פרופס:

```javascript
<IceCream serveType={serveType} />
```

### עכשיו נפתח את הקונסולה ונראה מה בעצם קרה כאן. כל פעם שהקומפוננטה אב משתנה, הפונקציה של הבן (גלידה) רצה מחדש. ואז מה שקורה זה שריאקט מרנדר מחדש אם צריך את הקומפוננטת בן. 

### עכשיו בואו נעשה עוד משהו, ננסה להשפיע על הבן, באמצעות האב.

נעשה דבר כזה:

```javascript
return (
    <div className={props.serveType}></div>
)
```

### צורות נוספות של סינטקסט

בכל שיעור או שניים, נעשה העמקה ב JS, מפני שבעצם, ריאקט בנוייה עם JS וכמה תוספות. אז דבר ראשון נדבר על DESTRUCTORING: 

בעצם ב JS, יש לנו אובייקטים, בתור האופן המרכזי להכיל סוגי מידע מורכבים. דרך אחת לגשת לפרופרטייז (לתכונות) של האובייקטים היא על ידי dot notation.
דרך נוסף היא DESTRUCTORING
Ternay experssion
היא שיטה נוספת לבצע בקרת זרימה של IF ELSE פשוט. 

```javascript
const person = { firsName: 'John', age: 30 };
const { firsName, age } = person;

// ternary expression
const isAdult = age > 18 ? 'yes' : 'no';
```

### עכשיו נראה איך נשנה את הקומפוננטה שלנו, לשימוש בשיטות האלו.

```javascript
export const IceCream = ({ serveType }) => {
    return (
        <div className={serveType === 'cone' ? 'cone' : 'cup'}></div>
    )
}
```

### עכשיו מדוע אנחנו שמים את הסוג של ההגשה בביטוי TERNARY?

בגלל שכדי להפריד את הדרך שבה אנחנו מייצגים את המידע במקומות שונים, כי אם נרצה לשנות את שם הקלאס בעתיד, אז זה יאפשר לנו לעשות את זה בצורה יותר קלה. 

### משימה - הוספת כפתור נוסף

אז הנה המשימות בקבוצות קטנות:
- למחוק את הסמלים React + Vite שבאו כברירת מחדל
- לשנות את הטקסט של הכפתור לעברית
- להוסיף עוד כפתור, שייצג האם אנחנו רוצים שוקולד או וניל
```