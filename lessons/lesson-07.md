<style>*{direction:rtl;}</style>
 
#קורס ריאקט חלק ז' - יציאה לרשת


# קורס ריאקט חלק ז' - יציאה לרשת

## פתיחה

עברנו על הרבה מהיכולות הבסיסיות של ריאקט. עכשיו ניגע בבקשות הרשת שיוצאות מהדפדפן.
בפעילות הזו, נלמד על קריאות שיוצאות מהדפדפן.

## מה זה בעצם בקשת רשת או בקשת HTTP?

כל האינטרנט בנוי על הקונספט של בקשות רשת, שנעסוק בהן עכשיו, יש עוד כמה סוגים אבל זו המרכזית.

זה בעצם פרוטוקול שבנוי מכל מני כללים, שבטח על חלקם עברתם כשעסקתם ב-BACK END.

## התנסות עם ENDPOINT של פלייסהולדר

לפני שניגש ממש לשמור את הזמנות הגלידה שלנו נתחיל עם התנסות עם אתר של פלייסהולדר.

לשם כך, ניצור עוד נתיב שנעבוד איתו בתוך האפליקציה שלנו, ואחרי זה נזיז אותו.

בתוך התקייה `examples` נשים עוד קובץ, שנקרא לו `NetworkRequests.jsx`.

נשים אותו ב-router, כמו שלמדנו:

```javascript
<Route path="/network" element={<NetworkRequests />} />
```

עכשיו כדי לעשות בקשת רשת, יש כמה סוגים. הסוג הראשון שכבר קוראת לנו בדפדפן, היא בקשת GET.

היא אומרת כשמה כן היא, תביא לי משהו.

עכשיו יש לדפדפן API מובנה לבקשות רשת שנקרא FETCH. אבל אנחנו נשתמש בספריה שנקראת AXIOS, משום שיש לה כמה פיצ'רים שמאפשרים עבודה נוחה יותר, עם בקשות רשת.

אז קודם כל נלך לעמוד של הספריה, נסתכל עליה:

[Axios Documentation](https://axios-http.com/docs/intro)

אז בדוקומנטציה יש לנו כל מני דוגמאות שיותר קשורות לסביבת NODE ופחות לסביבת דפדפן.

עכשיו בואו נראה את העמוד שלה ב-NPM:

[Axios NPM Package](https://www.npmjs.com/package/axios)

מה אני יכול לראות כאן מהעמוד הזה?

קודם כל שיש לה 60 מליון הורדות בשבוע. זה לא אומר שכל שבוע פותחים פרוייקט חדש, אבל כל פעם כשמשהו עושה `npm i` זה סופר את זה.
דבר שני יש לה המון ספריות שתלויות בה (150 אלף כדוגמא).

זה טוב, כי זה אומר שאם הספריה הזו תשתנה או תישבר וכו', לא רק אתם תהיו בבעייה אלא עוד 150 אלף \ או כמה מליונים של אנשים.

עוד דבר מעניין לראות שהיא בגרסא 1. מה זה אומר?

בעצם בגרסאות, יש גרסא מג'ורית ומינורית. גרסא מג'ורית זה המספר הראשון. כשמחליפים גרסא למשל מ-1 ל-2, זה אומר שיש שינויים שוברים, זה אומר שצריך לעשות שינוי בקוד, שחלק מהדברים אולי לא יעבדו.

כאן אתם רואים שהספריה לא השתנתה הרבה שנים. לאקו-סיסטם שלנו זה אומר דבר טוב בהרבה מובנים.

אם ניקח ספריה שאני יצרתי לדוגמא:

[hours-report NPM Package](https://www.npmjs.com/package/hours-report?activeTab=readme)

זו ספריה, שאני לא ממליץ להכניס לפרוייקט שלכם, כי יש לה רק מתחזק אחד (אני) ורק 20-30 הורדות בשבוע. אל תסמכו עליה.

יפה אז בואו נתקין את הספריה עם:

```bash
npm install axios
```

עכשיו נסתכל בקובץ ה-`package.json` שלנו לראות שהיא אכן הותקנה.

עכשיו בואו נלך לאתר jsonplaceholder נקרא קצת. זה אתר שבעצם מביא לנו placeholder, סתם מידע מזוייף כדי שנצליח להשתמש בו כדי ללמוד על בקשות רשת:

[JSON Placeholder](https://json-placeholder.mock.beeceptor.com)

הדוגמאות שיש שם זה על טודו. נקח את הפונקציה הזו. בהתחלה יש שם קצת דברים לא מובנים, בעיקר ה-`async await`. נגע בזה בהמשך:

```javascript
useEffect(() => {
    const fetchData = async () => {
        const response = await axios.get("https://json-placeholder.mock.beeceptor.com/posts");
        console.log(response);
    }
    fetchData();
}, [])
```

למדריך - רשימה של פלייסהולדים עם תוכן:
[Beeceptor JSON Placeholder](https://app.beeceptor.com/mock-server/json-placeholder)

בואו נראה בקונסולה מה אנחנו מקבלים מאקסיוס.

אז קודם כל חוזר אלינו אובייקט, עם הרבה דברים. אנחנו נתמקד רק ב-2 מהם: הסטטוס והדאטה.
שימו לב שבדאטה חזר אלינו מערך של פוסטים, כל פוסט מיוצג על ידי אובייקט.

## טאב הרשת בכלי מפתחים

כשעובדים עם בקשות רשת, יש כלי מפתחים מעולים בכל הדפדפנים, נעבוד עם כרום.

נעבור לטאב של הרשת. שימו לב שברירת המחדל היא על כל סוגי הבקשות. אנחנו נשים את זה על FETCH\XHR.

ונסתכל על הבקשות. דבר ראשון, נבחר את אחת הבקשות (נראה את הבקשה פעמיים בגלל ה-STRICT MODE).

קודם כל אנחנו רואים שיש לבקשה HEADERS כמה מאפיינים כלליים:
- URL
- METHOD
- STATUS CODE

המתודה - יש כמה מרכזיות שעושות מה שזה נשמע: GET, POST, PATCH, DELETE
הסטטוס קוד, זה מספרים קבועים שמקובלים באינטרנט למה קרה עם הבקשה.

## מה זה JSON

אז לפני שהיה JSON בקשות היו עוברות במשהו שנקרא XML שזה בגדול קצת דומה לתאגים של HTML וזה היה די סיוט לעבוד עם זה.
ואז הומצא ה-JSON שזה בגדול פורמט של שליחת אובייקט JS במחרוזת, עם חוקים מסויימים. למשל לא יכולים להיות בו פונקציות, וכל המחרוזות בו צריכות להיות עם מרכאות כפולות.
משתמשים ב-JSON היום כסטנדרט באינטרנט להמון סוגי בקשות מידע והוא אחת הצורות המרכזיות של תקשורת גם כשלא מדובר ב-JS.

## HTTP Headers

הן בעצם תוספות, או מעטפות מידע, שנשלחות בקריאות HTTP. הם נשלחות גם בבקשה, וגם בתשובה.
יש כמה HEADERS מקובלים, שבאים לומר למשל: איזה סוג תוכן אני רוצה לקבל, `Content-Type`, האם יש לי טוקן שאני מאומת וכו'.

למשל חלק מהיתרון של אקסיוס הוא שהוא דוחף כמה הדרס שהן ברירות מחדל, וגם ניתן לקנפג אותו ככה שאם יש לי טוקן (כמו סיסמה ומשתמש) אני יכול לשלוח אותם תמיד עם כל בקשה.

**דוגמה:** כשאני מקיש בדפדפן `https://www.google.com/`
מה הדפדפן עושה? הוא בעצם שולח בקשת GET לכתובת הזו. ברירת המחדל של הדפדפן היא `text/html`
בפועל הדפדפן שולח עוד סוגים כדי להתמודד עם מצבים שהכתובת היא של תמונה וכו'.

## קוד אסינכרוני

עכשיו ניגע בנושא שהוא נושא קצת קשה בפיתוח ב-JS, גם למפתחים שמגיעים משפות אחרות, שבהם אין קוד אסינכרוני. אולי אחד הנושאים הכי מבלבלים ב-JS.

מה זה אומר?

קוד אסינכרוני, זה קוד, שלא רץ בצורה רגילה של שורה אחר שורה, אלא מחכה לאירוע חיצוני.
כרגע נתעסק יותר בלראות איך עושים את זה וקצת להבין את ההגיון.

לשם ההבנה והקריאות אני לרגע מוציא את הפונקציה מתוך הקומפוננטה:

```javascript
const fetchData = async () => {
    const response = await axios.get("https://json-placeholder.mock.beeceptor.com/posts");
    console.log("response", response.data);
}

export const NetworkRequests = () => {
    useEffect(() => {
        console.log("before fetchData")
        fetchData();
        console.log("after fetchData")
    }, [])
```

בואו נפתח את הקונסולה ונראה מה קורה כאן.
לצורך הנושא נבטל גם את הסטריקט מוד.

בעצם אנחנו רואים משהו מעניין, שקודם כל רואים:
- before
- after

ורק אז רואים את מה שקרה בתוך הפונקציה FETCH DATA.

מה שקורה כאן, הוא, שכשפונקציה אסינכרונית רצה, היא יכולה לעשות משהו משונה:
כשיש `await`, היא בעצם מבצעת פעולה, שהיא "מחכה לה". אחרי שהפעולה התחילה, הקוד הסנכרוני ממשיך לרוץ רגיל, והקוד האסינכרוני, מחכה לזמן שבו הוא ירוץ שוב (כשהבקשה תחזור).

מה צריך לזכור כאן:
- בפונקציות אסינכרוניות, צריך לרשום את המילה `async` לפני הפונקציה
- ואז היא יכולה לחכות לכל מני תהליכים עם המילה `await`

יש עוד דרך להתעסק עם קוד אסינכרוני - להשתמש במילה `then` אחרי פונקציה אסינכרונית.

כרגע נחזיר את הקוד למצב הקודם, וכשרוצים להתעסק עם מידע שחוזר מהשרת, כרגע נעשה את זה ככה, עם ASYNC AWAIT.

## משימה 1

עכשיו אתם יכולים להגיע למצב של קריאה של פוסטים ממקור חיצוני, שאותם אתם מקבלים כאובייקט JS. עכשיו המשימה שלכם היא להציג על המסך את הפוסט הראשון.

### פתרון למשימה

נוסיף עוד משתנה עם סטייט:

```javascript
const [firstPost, setFirstPost] = useState(null);
```

ונציג:

```javascript
<h1> {firstPost.body} </h1>
<div>{firstPost.title}</div>
```

אבל יש לנו שגיאה, כי המשתנה יכול להיות גם NULL. אז מה נעשה?

נוסיף עוד תנאי שאם אין לנו עדיין את הפוסט אז אנחנו מראים סימן של טעינה:

```javascript
{firstPost ? (
    <div>
        <h1 className="font-bold mb-5"> {firstPost.title} </h1>
        <div>{firstPost.body}</div>
    </div>
) : (
    <span>Loading...</span>
)}
```

## משימה 2

נסו להציג את הפוסטים ברשימה עם הכותרת של כל פוסט.

### ביצוע המשימה:

```javascript
{allPosts ? (
    <div className="flex flex-col gap-5">
        {
            allPosts.map((post) => <div key={post.id} className="w-3/4 rounded-md p-2 flex flex-col items-start justify-start gap-2 border border-black">
                <h1 className="font-bold mb-5"> {post.title} </h1>
                <div>{post.body}</div>
            </div>)
        }
    </div>
) : (
    <span>Loading...</span>
)}
```

### דגשים:

נשתמש בפונקציה MAP כדי להפוך את המערך ליסודות של JSX. חשוב להכניס את ה-KEY כדי שריאקט ידע לעקוב אחרי שינויים במערך אם ישנם כאלו.

עכשיו נמשיך במשימות ובאותו כיוון, כדי לדמות התנהגות של הרבה מאד אתרים ואפליקציות פרונט. עכשיו קיבלנו את רשימת כל הפוסטים.

אבל אם אנחנו רוצים להעמיק\להכנס לפוסט אחד מסויים?

אם נכנס ל-[https://app.beeceptor.com/mock-server/json-placeholder](https://app.beeceptor.com/mock-server/json-placeholder) נראה שיש גם אנדפוינט שמיועדת רק לפוסט אחד.

## משימה 3

בנו אנדפוינט חדשה שתכיל את ID של הפוסט, וכשהיוזר יכנס אליה, הוא יראה את כל הפוסט ולא רק את הכותרת.

### דגשים:
- תשתמשו בדוגמא שכבר קיימת אצלנו בראוטר של ה-ORDERS
- תשימו את הקומפוננטה החדשה ב-EXAMPLES, כי היא לא תהיה חלק מהרכבי הסופי

### ביצוע משימה 3

אז קודם כל נוסיף אנדפוינט חדשה לפוסטים:

```javascript
<Route path="/post/:postId" element={<Post />} />
```

ועכשיו נוסיף קומפוננטה חדשה, שלא תעשה כלום עדיין רק כדי לראות הבסיס של הראוטר עובד:

```javascript
import { useParams } from "react-router";
export const Post = () => {
    const { postId } = useParams();

    return <div>
        post number {postId}
    </div>
}
```

עכשיו בואו נראה שהקומפוננטה והראוטר עובדים יפה ביחד.

עכשיו נוסיף את הלוגיקה של עדכון הפוסט:

```javascript
export const Post = () => {
    const { postId } = useParams();
    const [post, setPost] = useState(null);
   
    useEffect(() => {
        const fetchData = async () => {
            const response = await axios.get(`https://json-placeholder.mock.beeceptor.com/posts/${postId}`);
            setPost(response.data);
        }
        fetchData();
    }, [])


    return <div dir="rtl" className="p-14 w-screen min-h-screen flex flex-col items-start justify-start">
        {post ? (
            <div className="flex flex-col gap-5">
                <h1 className="font-bold text-2xl"> {post.title} </h1>
                <div className="text-xl"> {post.body} </div>
            </div>
        ) : (
            <span>Loading post number {postId}...</span>
        )}
    </div>
}
```

הדבר האחרון שנרצה לעשות, הוא להוסיף את הקישור לפוסט הספציפי ברשימת הפוסטים.

כדי לעשות את זה, קודם כל אני רוצה לעשות ריפקטורינג קטן, לשנות את השם של הקומפוננטה `requests` ל-`posts`, וגם את שם הנתיב, כדי שיתאים יותר למה שאנחנו עושים.

```javascript
<Route path="/all-posts" element={<AllPosts />} />
```

## ריפקטורינג

למה זה חשוב לעשות כאן ריפקטורינג ולשנות את השמות (כן, גם לשנות את השמות זה לעשות ריפקטורינג)? כי אם תגיע מפתחת (שאולי זו את עוד חצי שנה) ותשאל, למה הקומפוננטה שמציגה את הפוסט נקראת `NetworkRequests`?
אז בטח מה שתגידו לה, תשמעי, פעם זה היה קומפוננטה שעשתה משהו אחד, ואז זה השתנה, ואז השם נשאר.

אז למה חשוב לשנות? בכל מקרה לצערנו בתוכנה, יהיו דברים כאלו: טבלאות ב-DB, קומפוננטות, נתיבים, וכל מני שמות וכל מני שאריות הסטוריות מפעם. זה לא משהו שאפשר שלא יהיה בכלל. אבל המטרה היא לצמצמם אותם כמה שפחות.

אפשר לתת דוגמאות שונות. למשל במערכת ההרשמה שהיא מערכת של 10 שנים, יש עדיין "טלפנים" למרות לא קיים התפקיד טלפן. עכשיו מה הבעייה עם זה? עומס מנטלי. זה כמו לנהוג כשאומרים לך שברקס זה גז וגז זה ברקס.

גם ככה לתכנת זה קשה, צריך להקל כמה שיותר על המתכנתים.

ואז נוסיף לכל פוסט NavLink:

```javascript
<NavLink to={`/post/${post.id}`} className="text-blue-500 hover:underline">
    פתח פוסט
</NavLink>
```

זהו זה ברמת העקרון עובד. אבל… אנחנו רואים שלצערנו ה-MOCK API הזה לא באמת עובד כמו שאנחנו רוצים. כי כל פעם שמבקשים פוסט הוא יביא תמיד את אותו אחד.

בנתיים נעשה איזו רמאות קטנה:

```javascript
const fetchData = async () => {
    // This is a mock endpoint, so it will return the same data for every id.
    // this is the correct way to do it:
    // const response = await axios.get(`https://jsonplaceholder.typicode.com/posts/${postId}`);
    // setPost(response.data);
    const response = await axios.get(`https://json-placeholder.mock.beeceptor.com/posts`);

    const post = response.data.find((post) => post.id === parseInt(postId));
    setPost(post);
}
```

השארתי את ההערה בקוד, כדי שבפעם הבאה שנכנס לעבודה עם DB אמיתי, הדוגמא תשאר על איך זה צריך להיות באמת.
