<style>*{direction:rtl;}</style>

Turn this to MD file 

קורס ריאקט חלק ד' - יסודות ריאקט לעומק

פתיחה
בפעמים הקודמות התעסקנו עם המאפיינים הבסיסיים של ריאקט, ועבדנו עם TAILWIND כדי ליצור את הבסיסים הגרפיים של ריאקט. 

עכשיו נצלול קצת יותר לעומק להבין איך ריאקט עובד, ונראה כמה מאפיינים של מחזור החיים של כל קומפוננטה. 

מצגת

סוגי קומפוננטות שונים וההתנהגות שלהם

ריאקט היא פריימוורק או ספריה, שבא ללא "דעות" על איך צריך לבנות את האפליקציה שלכם. אני רוצה להראות כאן צורת חשיבה שלא חייבים לאמץ אותה לגמרי, אבל כן לחשוב עליה כעקרון מנחה. 

קומפוננטות עם סטייט ("מנהלות") - קומפוננטות שמתעסקות יותר בלוגיקה ופחות בפרזנטציה
קומפוננטות "ללא סטייט" - יותר לתצוגה  - קומפונטות שעוסקות יותר בתצוגה

מה שנעשה עכשיו זה תהליך שהוא ינסה לצמצם ולסדר קצת את הקוד שלנו. 

אז צעד ראשון, אנחנו יודעים שבהמשך נרצה לעשות עוד עמודים באפליקציה שלנו. כדי להפריד ביניהם נעשה קצת שינויים בקוד שלנו ובאיך שהוא עובד עכשיו. אבל בעצם נעשה ריפקטורינג.  שזה אומר שאנחנו לא רוצים שההתנהגות תשתנה, אלא רק המבנה הפנימי שיהיה יותר מסודר, קריא וברור. 

ניצור תקייה חדשה שנקראת pages. שם נשים את העמודים שלנו. העמודים שלנו בדרך כלל יהיו statefull components, שיכילו כל מני סוגים של סטייט. 

ניצור קובץ 

עכשיו איך נעשה את זה? נשתמש בכלי ה REFACTOR של ה VS-CODE. אפשר כמובן לעשות קופי פייסט בעצמנו, אבל הכלי הזה יעזור לנו לעשות את כל שינויים באיפמורט, נתיבים וכו'. 
נסמן את כל הקוד בקובץ ונלחץ על Refactor.



צריך לבחור 
move to a new file



ואז בקובץ APP שלנו נשים את העמוד (כרגע היחיד) שיש לנו:

import { IceCreamBuilderPage } from "./pages/IceCreamBuilderPage"


export const App = () => {
  return <IceCreamBuilderPage />
}

ריפקטור נוסף - הוצאת הכפתורים מתוך העמוד

כרגע הקומפוננטה שלנו  <IceCreamBuilderPage / >

מכילה את הלוגיקה של הבנייה, אבל יש בה גם הרבה מאד JSX שעוסק בתצוגה. כדי לעקוב אחרי העקרון של ההפרדה בין קומפוננטות של שליטה, לכאלו של תצוגה, נרצה להוציא את כל הלוגיקה הזו של התצוגה למקום אחר. 

אבל יש לנו בעייה. מפני שבחלק של הבנייה יש גם פונקציות שמשנות את הסטייט. מה עושים?

אז הדרך של ריאקט, היא שסטייט יורד מלמעלה למטה, כמו מפל. אבל לפעמים צריך להעלות סטייט למעלה. איך עושים את זה? על ידי העברה של functional props. 


מה שמיוחד כאן, הוא בעצם כי ב JS, אבל לא בכל שפות התכנות, פונקציות הן 
function as first class citizen

בעצם כל פונקציה גם פונקציה עם המילה FUNCTION וגם ARROW פונקשנס, הן בעצם יכולות להיות מוגדות בתור משתנים ויותר מזה, אפשר גם להעביר אותן לפונקציות אחרות. 

זהו קונספט מאד מבלבל, גם למי שמתחיל עם JS וגם למי שמתכנת מנוסה ומגיע משפות אחרות, שבהן אין את זה כמו JAVA ו CPP וכו' (לפחות לא כברירת מחדל של השפה) 

עכשיו שימו לב:

אחרי שהעברתי את הפונקציה כפרופ, הקומפוננטה שהעברתי אליה את הפונקציה יכולה לקרוא בעצמה לפונקציה הזו. 



אז נתחיל. נבנה קומפוננטה חדשה
IceCreamBuilderControls

ונעתיק לשם את הדברים. 
כמו שאנחנו מעבירים את הפרופס של סוג התוספות וכו' נעביר גם את הפונקציות שקובעות אותם. 

עכשיו זו התוצאה:
export const IceCreamBuilderPage = () => {
    const [serveType, setServeType] = useState('cone') // cone | cup
    const [taste, setTaste] = useState(null) // vanilla | chocolate | strawberry
    const [toppings, setToppings] = useState(IceCreamTopping.None) // none | cherry | sprinkles
    function toggleServeType() {
        if (serveType === 'cone') {
            setServeType('cup')
        } else {
            setServeType('cone')
        }
    }


    return (
        <div className="w-screen h-screen flex flex-col  ">
            <AppHeader />
            <div className='flex flex-col items-center justify-center   h-64'>
                <IceCream serveType={serveType} taste={taste} topping={toppings} />
            </div>
            <IceCreamBuilderControls serveType={serveType}
                taste={taste} toppings={toppings} toggleServeType={toggleServeType} setTaste={setTaste} setToppings={setToppings} />


        </div>
    )
}


יפה! עשינו את הריפקטור הראשון שלנו. זה חשוב מאד כי למשל UNCLE BOB שהוא אחד המפתחים הכי משפיעים ב20-30 השנים האחרונות, אומר שהעבודה של מפתח היא 50% לדאוג שהקוד יעבוד, ו 50% לעשות ריפקטורינג ונקיון וכו'. למה? 
כי חשוב לא רק שהקוד יעבוד, אלא שהוא יהיה קריא, וברור, ושיהיה קל לשנות אותו בעתיד. 

ריפקטוריג כולל גם להוריד כל מני הערות בקוד שאנחנו לא רוצים, לשנות מיקום של קבצים, לשנות שמות. 

אחד הערכים  החשובים בפיתוח הוא נקיון וקריאות הקוד, כי רוב הזמן אנחנו קוראים קוד, הרבה יותר ממה שאנחנו כותבים, בין אם זה להוסיף פיצ'ר, לתקן באג, וכו'. וככול שהקוד גדל וגדל, הוא נהיה יותר ויותר מסובך. 

שימו לב שעכשיו הקומפוננטה הזו היא שונה בכמה דרכים מלפני הריפקטור:

השם שלה יותר מדוייק ומסביר מה היא עושה (לא סתם APP)
היא עושה דבר אחד מרכזי (לנהל את הלוגיקה) ולא מתעסקת בפרטים של תצוגה
היא יותר קצרה ו"תמציתית" ולכן יותר קלה להבנה וקריאה. 


משימה:

עכשיו תעשו ריפקטור לקומפוננטה של הגלידה. רמז: כדאי לשים אותה בתיקייה נפרדת אם היא מכילה יותר מכמה קבצים. 



אז יפה הריפקטור הזה, כמו שאפשר לראות, הופך את האפליקציה שלנו מכזו עם מעט קבצים גדולים להרבה קבצים קטנים. 

איך ריאקט עובד

בואו ננסה עכשיו לצלול להבין איך ריאקט עובד מאחורי הקלעים.

בעצם כל קומפוננטה כמו שראינו היא פונקציה. פונקציה זה חתיכה של קוד, שרצה, כשקוראים לה. אז מתי בעצם קוראים לפוקנציה? 

ריאקט בעצם קורא לפונקציה (קומפוננטה) כל פעם כשיש שינוי בסטייט. 

למעשה ריאקט כל פעם כשיש שינוי בסטייט של קומפוננטה, הוא קורא לה, ולכן גם כל הקומפוננטות שהיא מכילה גם נקראות. 

בואו נראה:
 
נוסיף 

export const App = () => {
  console.log('App.jsx')
  return <IceCreamBuilderPage />
}

שימו לב שבפעם הראשונה שהעלתי את האפליקציה, הפונקציה הזו רצה. אבל אז אם אני עושה כל מני שינויים, היא לא רצה. 



שימו לב שאנחנו נראה בקונסול לוג פעמיים APP.JSX זה רק בגלל שאנחנו במצב פיתוח, כשה STRICKMODE פעיל. 

זה טוב שהוא פעיל כי הוא עוזר לנו למצוא כל מני בעיות בזמן הפיתוח, למשל, אם אנחנו עושים משהו לא נכון מבחינת ריאקט (נראה את זה בהמשך עם רשימות וטפסים)

מה שזה עושה זה מריץ את הקומפוננטות שלנו פעמיים לראות אם יש פער בין הרצה אחת לשניה, אם יש הוא מתריע.

נראה שאם נוריד את סטריקט מוד, זה יפסיק להציג את ההודעה פעמיים.


  <StrictMode>
    <App />
  </StrictMode>,





עכשיו אם אני שם קונסול לוג ב 


   export const IceCreamBuilderPage = () => {
 console.log('IceCreamBuilderPage.jsx')

עכשיו אם אני שם קונסול לוג ב 


ננסה לשחק קצת עם האפליקציה ונראה מה קורה?

כל פעם כשמשתנה הסטייט הפונקציה רצה. 

עכשיו תראו משהו מעניין
 
 export function AppHeader() {
    console.log("AppHeader.jsx")




נוסיף עוד קונסול לוג לAPP HEADER. הוא לא מקבל שום פרופס, אז בעצם הוא לא משתנה. למרות זו, מכיוון שהוא ילד של קומפוננטה שכן משתנה הסטייט שלה, הפונקציה רצה שוב. 

דום וירטואלי

עכשיו אם כל פעם שמתשנה הסטייט בקומפוננטה, צריך לכתוב את כל ה HTML מחדש זה כמובן דבר מאד בזבזני מבחינת ביצועים. תחשבו שזה יהיה (כמעט כמו) לטעון את כל הדף מחדש!

אז צריך להבין שיש עוד שלב אחד בדרך, והוא קשור ל VIRTUAL DOM



תזכורת: ה DOM זה בעצם הHTML. מה ההבדל? ה DOM זה ה DOCUMENT OBJECT MODEL, או בעצם איך ש JS יכול לגשת ת HTML דרך כל מני פונקציות, בעיקר:
docuemnt.getElement
document.createElement





בעצם כשריאקט קורא לפונקציה של קומפוננטה, התוצאה היא לא שינוי ה HTML, לפחות לא ישר. 

בוא נראה מה התוצאה. נעשה משהו כזה:

export const App = () => {
  console.log(AppHeader())
  return <IceCreamBuilderPage />
}

זה קצת מוזר לקחת את הקומפוננטה ולקרוא לה כפונקציה, אבל בואו נזכור שכל קומפוננטה היא בעצם פשוט פונרציה של JS בסך הכל. 

כל קרירה מחדש של חלק מהעץ קומפוננטות שלנו נקרא 
Render cycle 
אבל השם מבלבל, כי לא תמיד יש רינדור (שינוי מה שרואים על המסך). עוד מעט נרחיב על זה. 


עכשיו בואו נראה מה התוצאה בקונסולה:



יש לנו כאן אובייקט גדול ומוזר. אבל אם תסתכלו בתוכו בתוך CHILDREN תראו כל מני דברים שהם בעצם ייצוג של HTML. 

אז מה בעצם ריאקט עושה? 

לריאקט יש עותק של הDOM, שנראה בערך כמו שאתם רואים כאן: מה האלמנט, מה הסוג שלו, מה הפרופרטיז שלו, כמו קלאס NAMES וכו'. העותק הוא בצורת אובייקט JS. 

העותק הזה נקרא VIRTUAL DOM

ואז ריאקט עושה השוואה בין מה שיש לו עכשיו, לבין העדכון. אם הוא רואה שיש הבדל, הוא מעדכן (בתקווה…) רק את החלק שרלוונטי ב HTML. 

לפעמים ריאקט יקבץ כמה שינויים במקביל לשם אופטימיזציה, אבל מאד קשה לשלוט בזה. 

זו הדרך המרכזית בה ריאקט עובד ובעצם זה הרבה מה"קסם" של ריאקט. 


Useeffect 


עכשיו שלמדנו על איך ריאקט עובד נלמד על 3 הוקס נוספים: 
אחד חשוב שמשתמשים בו הרבה ואחד פחות חשוב ויותר נדיר, אבל שקשור לרעיונות שלנו. 


אז בעצם לפי מה שראינו, פונקציית הרנדור (שלא תמיד משנה את הדום עצמה, אבל היא בעצם פונרציה שיוצרת דום וירטואלי) יכולה לרוץ בין 0 ל אין ספור פעמים. אבל מה אם אנחנו רוצים שיהיו דברים שיקרו לא תמיד כשהיא רצה אלא רק בנסיבות מסויימות?

לשם כך נכיר את ההוק USE EFFECT:

נייבא אותו מריאקט ונשים אותו ב ICE CREAM VISUAL

export const IceCream = ({ serveType, taste, topping }) => {
    useEffect(() => {
        console.log('use effect')
    })


עכשיו ההוק הזה מקבל פונקציה ללא ארגומנטים. בואו נקרה מתי היא נקראת:

אז בפעם הראשונה היא נקראת פעמיים (בגלל ה STRICT MODE שדיברנו עליו מקודם). אבל בפעמים הבאות היא בעצם נקראת כל פעם כשהפונקצייה של הקומפוננטה נקראת. 
אז זה בעצם לא ממש מועיל לנו נכון? אז יש לנו יכולת להוסיף עוד פרמט ל USE_EFFECT שזהו בעצם מערך שאומר, מתי אנחנו רוצים לקרוא ל USE EFFECT. 
במערך הזה נשים רשימה של משתנים. 
רק כשאחד מהם ישתנה  USE_EFFECT תיקרא. 
בואו ננסה את זה עם TASTE
    useEffect(() => {
        console.log('[use effect] taste changed', taste)
    }, [taste])

שימו לב שרק כש TAST נקרא הקומפוננטה משתנה. 
בנוסף שימו לב שתמיד היא תקרא בפעם הראשונה שהפונקציה נקראה. 
עכשיו יש איזה "טריק" למרות שהוא לא ממש האק אלא הוא הדרך הרשמית לטפל בזה, אם אני מעביר מערך ריק: הוא אומר לריאקט, תקרא לפונקציה הזו רק כש"אף ערך לא משתנה". מה זה אומר? 

אם מעבירים מערך ריק, זה אומר שהפונרציה תקרא רק בפעם הראשונה

מתי להשתמש ב USE_EFFECT ? 

בנוסף, הפונקציה של useeffect יכולה להחזיר גם פונקציה. הפונקציה הזו תקרא כשהקומפוננטה  תוסר מה dom. 

אז בדרך כלל נשתמש בה כשרוצים לעשות איזה cleanup. 

אנסה להדגים שימוש ב useEffect  הוא לא אמיתי לגמרי אבל כן לפעמים משתמשים בו לשם מניפולציה של הדום. נניח  שרוצים שרק פעם ראשונה שלוחצים על הדובדבן הוא יעשה איזה אנימציה. 

אז קודם כל אני אעשה שלא תמיד הקומפוננטה של הטופינקס מתרנדרת, רק כשמופיעה תוספת. כרגע המצב הוא שהיא תמיד מתרנדרת:

{{ backgroundColor: scoopColor(taste) }}>
                    {topping !== IceCreamTopping.None ? <Toppings topping={topping} /> : null}


                </div>


ואז נוסיף לקומפוננטה הזו, את ה USE_EFFECT

   useEffect(() => {
        const imageElement =
            document.getElementById('toppings-image');
        const bounceImage = () => {
            imageElement.classList.add('animate-bounce')
        }
        imageElement.addEventListener('click', bounceImage)
    }, [])


זה טוב ויפה, הבעייה עם AddEventListner זה שהדפדפן שומר את הפונקציה הזו בזיכרון, עד שמסירים אותו. 
אז בואו נעשה כאן CLEANUP

    useEffect(() => {
        console.log('started')
        const imageElement =
            document.getElementById('toppings-image');
        const bounceImage = () => {
            imageElement.classList.add('animate-bounce')
        }
        imageElement.addEventListener('click', bounceImage)


        return () => {
            console.log('cleanup')
            imageElement.removeEventListener('click', bounceImage)
        }
    }, [])


UseMemo

זה הוק שהשימוש בו נדיר, ולמעשה אני רואה  לרוב שמשתמשים בו לרוב שלא לצורך. 

מה בעצם הוא עושה? הוא משתמש בטכניקה שנקראת ממואזישן. זה דומה למילה memory באנגלית, והיא נובעת גם המילה הזו. הטכניקה הזו אומרת כך:

פונקציה שההרצה שלה  יקרה, מבחינת זיכרון או עיבוד, אפשר לקרוא לה פעם אחת, לזכור את התוצאה, ופעם הבאה שתקרא לה אם כל הפרמטרים שלה לא השתנו, במקום להריץ אותה שוב, פשוט להחזיר את התוצאה. 
 

בואו נראה דוגמה

    const memoToppings = useMemo(() => <Toppings topping={topping} />, [topping])


שימו לב, מה שצריך להיות כאן זה הוק שמקבל 2 ארגומנטים, אחד פונקציית פקטורי, שאמורה להחזיר את הקומפוננטה, והשנייה זה מערך תלויות. 

עכשיו נראה ש TOPPINGS מתרנדר רק כאשר יש שינוי בטופינגס ולא בכל דבר אחר. 

דוגמה לבעיית פרפורמנס

    for (let i = 0; i < 10000000; i++) {
        const b = document.getElementById('root')
        b.classList.add('asdfasdf')
    }


Turn this to MD file 


אזהרה

למרות שזה קורץ להשתמש בה לשם פרפורמנס, לא תמיד  זה רלוונטי:
- לפעמים משתמשים בזה ואז שוכחים כשמוסיפים עוד פרמטרים וסטייט ואז שוכחים לעדכן את הmemo. 
- הפונקציה עצמה, כן מוסיפה overhead מבחינת חישוביות וזיכרון



לכן אני ממליץ להשתמש בזה במקרה שהישום מתחיל להיות איטי יחסית, אז שימו usememo  ותראו האם זה משפר. 

Refs

דבר נוסף שיש לנו אפשרות לעשות הוא להתדמש במשהו שנקרא ref. 

בעצם כמו שלמדנו פונקציה של ריאקט יכולה לרוץ כל פעם מחדש וכל פעם כל מה שקורה בפונקציה לא נשמר. 
יש דרך לשמר ערך או הפנייה מסויימת, לכל מני מטרות, בעיקר כמו שנראה לקשר לאלמנטי של html. 

נתן דוגמה של פוקוס. נניח שאנחנו רוצים שהכפתור של בחירת הטעם יקבל פוקוס (ב HTML חלק מהאלמנטים יכולים לקבל פוקוס בצורה של מעיין קו שמקיף אותם, זה משמש גם לענייני נגישות ושימוש במקלדת)

אז בתוך הקומפוננטה של הקונטרולס:

  const buttonRef = useRef(null)
 
ונקשר את האלמנט לREF בצורה כזו, זוהי תכונה מיוחדת שיש לכל אלמנט של ריאקט.

<button ref={buttonRef}> </button>



נראה מה נקבל בקונסול לוג:


שימו לב שאנחנו מקבלים אובקייט שיש לו פרופרטי אחת: current. והוא מצביע על הכפתור הזה שדיברנו עליו.

עכשיו בואו נעשה לו פוקוס:
   const buttonRef = useRef(null)
    buttonRef.current.focus()

עכשיו מה קרה לנו כאן?

שימו לב, בעצם הREF, בפעם הראשונה שהפוקנציה רצה, לא מקושרת לאלמנט הכפתור, כי הוא עדיין לא קיים. 
מה נעשה?

נשים את זה בתוך USE_EFFECT

   useEffect(() => {
        buttonRef.current.focus()
    }, [])


הערה:

הצפייה כאן היא לא שתזכרו את הכל בעלפה אלא יותר שתכירו את הלך הרוח של ריאקט, ואת החשיבה בזמן עדכון סטייט. 

ContextApi


כמו שראינו אם קומפוננטה שמכילה קומפוננטה אחרת רוצה לשלוט בה / בהתנהגות שלה, אז היא מעבירה לה פרופס. 

עכשיו לפעמים יש לנו סטייט שנמצא גבוה גבוה בעץ ואז אנחנו צריכים לדעת בקומפוננטה  שנמצאת במקום נמוך בעץ את המידע. איך נעשה את זה ?

אז בואו נגיד שאנחנו רוצים לדעת אם היוזר מחובר או לא, כדי להוסיף כפתור לתשלום או לא? 

אז בואו נעשה דבר כזה, אפילו בלי להתעסק עם זה(נעשה את זה בעתיד)  נוסיף סטייט שנקרא לו isAuth, ונעביר אותו מה app למטה. 

בואו נעשה אז זה:
  const [isUserAuth, setIsUserAuth] = useState(false)
  return <IceCreamBuilderPage isUserAuth={isUserAuth} />




עכשיו שימו לב מה קרה, העברתי את המשתנה הזה כמה פעמים למטה. גם זה הרבה עבודה. וגם אם הוא משתנה אז צריך לשנות אותו בהרבה מקומות. 

התהליך הזה של הורדת משתנה למטה נקרא פרופ דרילינג, כי בעצם אנחנו כאילו "קודחים" למטה ולמטה ולמטה. 

אז בגלל הבעייה הזו, לריאקט יש מנגנון שנקרא קונטסט. 

הוא בעצם נועד למנוע את העניין של הפרופ דרילינג. 

בואו נראה איך משתמשים בו:

אפתח תקייה חדשה שנקראת context


import { createContext } from "react";


export const GlobalContext = createContext({ isAuth: false })




דבר ראשון, לשם הבהירות יצרנו את הקונטקסט עצמו.
אבל זה לא מספיק. בעצם צריך לראות קונטקסט בתור מעיין סטייט או useState, אבל סטייט שיכול לחלחל בכל העץ. 

עכשיו ניצור קומפוננטה שתספק אותו לכל מי שיהיה מתחתיה בעץ:

import { createContext, useState } from "react";
import { GlobalContext } from "./globalContext";


export const GlobalContextProvider = ({ children }) => {
    const [isAuth, setIsAuth] = useState(true)
    return <GlobalContext.Provider value={{ isAuth, setIsAuth }}>
        {children}
    </GlobalContext.Provider>
}


עכשיו כדי לצרוך את הקונטקסט נשתמש בהוק בתוך הקומפוננטה של הקונטרולס

   const { isAuth } = useContext(GlobalContext);